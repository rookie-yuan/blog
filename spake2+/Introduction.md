# SPAKE2+ 协议详解

## 协议概述

SPAKE2+（Simple Password Authenticated Key Exchange v2+）是一种密码认证密钥交换（PAKE）协议。它允许两个只共享一个弱密码的参与方安全地建立一个共享的强密钥，即使在存在主动攻击者的情况下也能抵抗字典攻击。

## 核心特性

- **密码认证**：使用低熵密码进行认证
- **防字典攻击**：即使密码被猜测，也无法通过离线攻击获取密钥
- **前向保密性**：会话密钥的泄露不会危及密码安全
- **相互认证**：双方都能验证对方知道正确的密码
- **简洁高效**：计算复杂度低，适合资源受限设备

## 协议参与方

- **Prover（验证方/客户端）**：知道密码 pw 的一方
- **Verifier（服务器）**：存储密码验证值的一方  
- **共享密码**：pw（仅 Prover 知道，Verifier 存储 w = H(pw)）

**注意**：SPAKE2+ 是增强型 PAKE（Augmented PAKE），只有一方知道明文密码，这与传统的平衡型 PAKE（如 SPAKE2）不同。

## 协议参数

### 基本参数

- **Group**：循环群（通常为椭圆曲线）
- **H()**：哈希函数（如 SHA-256）
- **KDF()**：密钥推导函数
- **M, N**：预定义的群元素（与 SPAKE2 不同的是 SPAKE2+ 中这两个元素与密码相关）

### 派生参数

- **x, y**：随机标量（Prover 和 Verifier 的临时随机数，非长期私钥）
- **X = g^x · M^w**（Prover 的掩蔽公钥）
- **Y = g^y · N^w**（Verifier 的掩蔽公钥）
- **w = H(pw)**：密码的哈希值

## 离线注册 vs 在线认证

SPAKE2+ 分为两个关键阶段，各有不同的目的和流程：

### 离线注册（Offline Registration）

**执行时机**：初次注册账户时进行，**不经过网络**

**详细流程**：

```
1. Prover 输入密码 pw
2. Prover 确定身份标识
   - idProver：Prover 的身份（如用户名）
   - idVerifier：Verifier 的身份（如服务器标识）
3. Prover 使用 PBKDF（密码基密钥推导函数）计算：
   w0s || w1s = PBKDF(len(pw) || pw ||
                       len(idProver) || idProver ||
                       len(idVerifier) || idVerifier)
4. Prover 将密钥材料缩放到群的标量范围：
   w0 = w0s mod p
   w1 = w1s mod p
5. Prover 计算认证参数：
   L = w1 · g  （后续在线认证时会用到）
   M = g^w0    （Verifier 用此进行掩蔽）
6. 存储结果：
   - Prover 端：保存 w0, w1, L 和密码
   - Verifier 端：接收并存储 w0（或直接计算 M = g^w0）
```

**特点**：
- 一次性操作
- 计算量较大（PBKDF 使用慢速哈希防暴力）
- 包含身份信息确保跨平台密钥独立性
- 结果存储在 Prover 和 Verifier 两端

---

### 在线认证（Online Authentication）

**执行时机**：每次登录时进行，**通过网络进行实时通信**

**详细流程**：

```
第一步：Prover 生成临时随机数并发送掩蔽公钥
1. Prover 生成随机数 x ∈ [1, q-1]
2. Prover 计算掩蔽公钥：X = g^x · M^w0
3. Prover 发送 X 到 Verifier

第二步：Verifier 生成临时随机数并响应
4. Verifier 生成随机数 y ∈ [1, q-1]
5. Verifier 计算掩蔽公钥：Y = g^y · N^w0
6. Verifier 发送 Y 到 Prover

第三步：双方计算共享密钥（去掉掩蔽）
7. Prover 计算：Z = (Y · (N^w0)^-1)^x = g^(xy)
8. Verifier 计算：Z = (X · (M^w0)^-1)^y = g^(xy)
9. 双方都得到相同的 Z = g^(xy)

第四步：密钥导出和认证标签生成
10. 双方都计算：K = KDF(Z || X || Y || w0 || ...)
11. Prover 计算：auth_P = H(K || "client" || ...)
12. Verifier 计算：auth_V = H(K || "server" || ...)

第五步：交换并验证认证标签
13. Prover 发送 auth_P 到 Verifier
14. Verifier 验证接收到的 auth_P 是否正确
15. Verifier 发送 auth_V 到 Prover
16. Prover 验证接收到的 auth_V 是否正确
17. 如果都验证通过，会话建立成功，K 可安全使用
```

**特点**：
- 每次登录重复执行
- 计算量较小（主要是群运算）
- 利用离线注册阶段的 w0 值
- 实时网络通信（通常 4 条消息往返）

---

### 对比总结

| 特征 | 离线注册 | 在线认证 |
|------|--------|--------|
| **执行时机** | 初次设置，一次性 | 每次登录，重复执行 |
| **网络通信** | 否 | 是（多条消息往返） |
| **计算复杂度** | 高（PBKDF 慢速哈希） | 低（快速群运算） |
| **主要目的** | 生成和存储认证参数 | 进行身份验证和密钥交换 |
| **参与方** | 仅 Prover（客户端） | Prover 和 Verifier 双方 |
| **关键数据** | 生成 w0, w1, L | 使用 w0 进行认证 |
| **输入参数** | 密码、身份信息 | 临时随机数、掩蔽公钥 |
| **安全敏感度** | 高（保护密码和 w 值） | 高（临时密钥交换） |
| **可否重复使用数据** | 是（w0 多次使用） | 否（x, y 每次新生成） |

---

### 流程关系图

```
┌─────────────────────────────────────────────────────┐
│           初始化阶段（离线注册）                      │
│  ┌────────────────────────────────────────────────┐  │
│  │ 1. 输入密码 pw 和身份 (idProver, idVerifier)    │  │
│  │ 2. PBKDF 计算 w0s, w1s                        │  │
│  │ 3. 模 p 缩放得到 w0, w1                      │  │
│  │ 4. 计算 L = w1·g, M = g^w0                  │  │
│  │ 5. 存储：Prover 端(w0, w1, L)                │  │
│  │         Verifier 端(M 或 w0)                │  │
│  └────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                          │
                          │ 使用 w0 值
                          ↓
┌─────────────────────────────────────────────────────┐
│        登录阶段（在线认证）- 每次登录                │
│  ┌────────────────────────────────────────────────┐  │
│  │ 1. Prover 生成 x，计算 X = g^x·M^w0          │  │
│  │ 2. Prover 发送 X                             │  │
│  │ 3. Verifier 生成 y，计算 Y = g^y·N^w0        │  │
│  │ 4. Verifier 发送 Y                           │  │
│  │ 5. 双方去掉掩蔽，计算 Z = g^(xy)            │  │
│  │ 6. 派生会话密钥 K = KDF(Z, X, Y, w0, ...)  │  │
│  │ 7. 生成认证标签 auth_P, auth_V              │  │
│  │ 8. 交换验证认证标签                          │  │
│  │ 9. 会话建立成功                              │  │
│  └────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

---

## SPAKE2+ 协议流程

### 第一阶段：初始化和计算

```
Prover 端:
1. 生成随机数 x ∈ [1, q-1]
2. 计算 X = g^x · M^w
   （其中 M 是预定义的群元素，w = H(pw)）
3. 将 X 发送给 Verifier

Verifier 端:
1. 生成随机数 y ∈ [1, q-1]
2. 计算 Y = g^y · N^w
   （其中 N 是预定义的群元素，w = H(pw)）
3. 将 Y 发送给 Prover
```

### 第二阶段：密钥计算

```
Prover 端:
1. 接收 Y
2. 计算 Z = (Y · (N^w)^-1)^x = (g^y)^x = g^(xy)
   （即通过群运算逆元去掉 Y 中的 N^w 掩蔽，得到纯 g^y，再进行 x 次幂）

Verifier 端:
1. 接收 X
2. 计算 Z = (X · (M^w)^-1)^y = (g^x)^y = g^(xy)
   （即通过群运算逆元去掉 X 中的 M^w 掩蔽，得到纯 g^x，再进行 y 次幂）

双方都得到相同的共享密钥 Z = g^(xy)
```

### 第三阶段：密钥导出和认证

```
双方都计算:
1. K = KDF(Z || X || Y || w || "SPAKE2+")
   （使用密钥推导函数从共享密钥 Z 导出）
2. auth_A = H(K || "client" || X || Y)
3. auth_B = H(K || "server" || X || Y)
```

### 第四阶段：认证消息交换

```
Prover → Verifier: auth_P
Verifier → Prover: auth_V

验证:
Prover: 验证接收到的 auth_V 是否与计算值匹配
Verifier: 验证接收到的 auth_P 是否与计算值匹配

如果验证通过，双方都确认对方知道正确的密码，会话密钥 K 可以安全使用
```

## 详细流程图

```
Prover (客户端)              Verifier (服务器)
  |                              |
  |-- 生成 x 随机数 --|
  |-- 计算 X=g^x·M^w --|
  |                              |
  |         X 发送              |
  |----------------------------->|
  |                          |- 生成 y 随机数
  |                          |- 计算 Y=g^y·N^w
  |         Y 发送              |
  |<-----------------------------|
  |                              |
  |- 计算 Z=(X·(M^w)^-1)^y  |- 计算 Z=(Y·(N^w)^-1)^x
  |- 导出 K=KDF(Z...)       |- 导出 K=KDF(Z...)
  |- 计算 auth_P            |- 计算 auth_V
  |                              |
  |       auth_P 发送            |
  |----------------------------->|
  |                          |- 验证 auth_P
  |       auth_V 发送            |
  |<-----------------------------|
  |- 验证 auth_V                |
  |                              |
  |------- 会话建立 -------       |
```

## SPAKE2 vs SPAKE2+ 的主要区别

| 特性 | SPAKE2 | SPAKE2+ |
|------|--------|---------|
| 协议类型 | 平衡 PAKE（双方都知道明文密码） | 增强型 PAKE（仅 Prover 知道明文密码） |
| 参与方角色 | Initiator 和 Responder（对称） | Prover 和 Verifier（不对称） |
| M, N 的使用 | 固定的群元素 | 与密码相关的掩蔽（M^w, N^w） |
| Verifier 存储 | 不存储（双方对等） | w = H(pw) 的预计算值 |
| 密钥导出 | 简单拼接 | 包含更多上下文（消息、身份等） |
| 防字典攻击 | 基础防护 | 增强防护（Augmented PAKE） |
| 前向保密性 | 有 | 有 |
| RFC 标准 | RFC 8235 | RFC 9383 |
| 适用场景 | 双方预先共享密码 | 服务器-客户端认证（如注册服务） |

## 安全性分析

### 防护能力

1. **离线字典攻击防护**
   - 即使攻击者截获所有网络消息，也无法离线验证密码猜测
   - 关键在于：掩蔽层 M^w 和 N^w 的存在使得每次猜测都需要执行昂贵的群运算
   - 与 SPAKE2 不同的是：Verifier 不存储明文密码信息，进一步增强了安全性

2. **主动攻击防护**
   - 双向认证（auth_P 和 auth_V）确保没有中间人
   - 认证标签包含会话上下文信息，防止消息重放

3. **会话密钥安全（前向保密性）**
   - 即使密码被泄露，历史会话密钥仍然安全
   - 由于 x 和 y 是一次性随机数，每个会话都独立

### 已知限制

- 密码必须有足够的熵（建议至少 20 比特，通常 32+ 比特更安全）
- 容易受到弱密码的在线暴力攻击（需要服务器端的速率限制防护）
- Prover 和 Verifier 角色不对称，Verifier 需要妥善保护存储的 w 值

## 实际应用场景

- IoT 设备配对
- 家庭网络设备认证
- 移动应用登录（配合其他因素）
- 云服务初始认证
- Matter 智能家居标准（使用 PAKE）

## 参考实现

- RFC 9383：SPAKE2+ 标准规范
- libpake：开源 PAKE 库
- Google Tink：密码库中包含 SPAKE2+ 实现

